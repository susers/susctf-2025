#include <cstdio>
#include <Windows.h>
#include <winternl.h>
#include <cstdint>

#define Delta 0xdeadbeef
#define FlagLen 32

// 全局变量区域
unsigned char key[] = { 0x65, 0x6c, 0x67, 0x76, 0x64, 0x69, 0x73, 0x6c, 0x68, 0x61, 0x70, 0x79, 0x62, 0x73, 0x79, 0x22, 0x0 };
unsigned char xor_delta[] = { 1, 9, 2, 6, 0, 8, 1, 7 };
unsigned char add_delta[] = { 2, 0, 2, 5, 1, 0, 0, 1 };
unsigned char flag[] = { 0x6f, 0x47, 0xa, 0x56, 0xd1, 0x3a, 0xbc, 0xf8, 0xe3, 0x93, 0xc2, 0xa6, 0x11, 0x8f, 0xb, 0x6f, 0xf7, 0x7d, 0xa5, 0x81, 0x57, 0x32, 0xb3, 0xf5, 0x61, 0x85, 0x70, 0xa0, 0xe1, 0x93, 0x39, 0xec, 0 };
unsigned char success_msg[] = { 0x70, 0x64, 0x67, 0x68, 0x23, 0x6c, 0x71, 0x23, 0x6b, 0x64, 0x79, 0x68, 0x71, 0x24, 0 };
unsigned char failed_msg[] = { 0x6d, 0x6e, 0x1f, 0x6d, 0x6e, 0x20, 0 };

void my_xor_eq(unsigned char* num1, unsigned char num2) {
	__asm {
		_emit 0x88
		_emit 0x54
		_emit 0x24
		_emit 0x10
		_emit 0x48
		_emit 0x89
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0xf
		_emit 0xb6
		_emit 0x44
		_emit 0x24
		_emit 0x10
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0xf
		_emit 0xb6
		_emit 0x9
		_emit 0x33
		_emit 0xc8
		_emit 0x8b
		_emit 0xc1
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0x88
		_emit 0x1
		_emit 0xc3
	}
}

void my_sub_eq(unsigned char* num1, unsigned char num2) {
	__asm {
		_emit 0x88
		_emit 0x54
		_emit 0x24
		_emit 0x10
		_emit 0x48
		_emit 0x89
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0xf
		_emit 0xb6
		_emit 0x44
		_emit 0x24
		_emit 0x10
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0xf
		_emit 0xb6
		_emit 0x9
		_emit 0x2b
		_emit 0xc8
		_emit 0x8b
		_emit 0xc1
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0x88
		_emit 0x1
		_emit 0xc3
	}
}

void tea(uint32_t* v, const uint32_t* k) {
	__asm {
		_emit 0x48
		_emit 0x89
		_emit 0x54
		_emit 0x24
		_emit 0x10
		_emit 0x48
		_emit 0x89
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0x48
		_emit 0x83
		_emit 0xec
		_emit 0x18
		_emit 0xc7
		_emit 0x44
		_emit 0x24
		_emit 0x8
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0xb8
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc0
		_emit 0x0
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x20
		_emit 0x8b
		_emit 0x4
		_emit 0x1
		_emit 0x89
		_emit 0x4
		_emit 0x24
		_emit 0xb8
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc0
		_emit 0x1
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x20
		_emit 0x8b
		_emit 0x4
		_emit 0x1
		_emit 0x89
		_emit 0x44
		_emit 0x24
		_emit 0x4
		_emit 0xc7
		_emit 0x44
		_emit 0x24
		_emit 0xc
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0xeb
		_emit 0xa
		_emit 0x8b
		_emit 0x44
		_emit 0x24
		_emit 0xc
		_emit 0xff
		_emit 0xc0
		_emit 0x89
		_emit 0x44
		_emit 0x24
		_emit 0xc
		_emit 0x83
		_emit 0x7c
		_emit 0x24
		_emit 0xc
		_emit 0x20
		_emit 0xf
		_emit 0x8d
		_emit 0xa7
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x8b
		_emit 0x44
		_emit 0x24
		_emit 0x8
		_emit 0x5
		_emit 0xef
		_emit 0xbe
		_emit 0xad
		_emit 0xde
		_emit 0x89
		_emit 0x44
		_emit 0x24
		_emit 0x8
		_emit 0x8b
		_emit 0x44
		_emit 0x24
		_emit 0x4
		_emit 0xc1
		_emit 0xe0
		_emit 0x4
		_emit 0xb9
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc9
		_emit 0x0
		_emit 0x48
		_emit 0x8b
		_emit 0x54
		_emit 0x24
		_emit 0x28
		_emit 0x3
		_emit 0x4
		_emit 0xa
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0x8b
		_emit 0x54
		_emit 0x24
		_emit 0x4
		_emit 0x3
		_emit 0xd1
		_emit 0x8b
		_emit 0xca
		_emit 0x33
		_emit 0xc1
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x4
		_emit 0xc1
		_emit 0xe9
		_emit 0x5
		_emit 0xba
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xd2
		_emit 0x1
		_emit 0x4c
		_emit 0x8b
		_emit 0x44
		_emit 0x24
		_emit 0x28
		_emit 0x41
		_emit 0x3
		_emit 0xc
		_emit 0x10
		_emit 0x33
		_emit 0xc1
		_emit 0x8b
		_emit 0xc
		_emit 0x24
		_emit 0x3
		_emit 0xc8
		_emit 0x8b
		_emit 0xc1
		_emit 0x89
		_emit 0x4
		_emit 0x24
		_emit 0x8b
		_emit 0x4
		_emit 0x24
		_emit 0xc1
		_emit 0xe0
		_emit 0x4
		_emit 0xb9
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc9
		_emit 0x2
		_emit 0x48
		_emit 0x8b
		_emit 0x54
		_emit 0x24
		_emit 0x28
		_emit 0x3
		_emit 0x4
		_emit 0xa
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x8
		_emit 0x8b
		_emit 0x14
		_emit 0x24
		_emit 0x3
		_emit 0xd1
		_emit 0x8b
		_emit 0xca
		_emit 0x33
		_emit 0xc1
		_emit 0x8b
		_emit 0xc
		_emit 0x24
		_emit 0xc1
		_emit 0xe9
		_emit 0x5
		_emit 0xba
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xd2
		_emit 0x3
		_emit 0x4c
		_emit 0x8b
		_emit 0x44
		_emit 0x24
		_emit 0x28
		_emit 0x41
		_emit 0x3
		_emit 0xc
		_emit 0x10
		_emit 0x33
		_emit 0xc1
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x4
		_emit 0x3
		_emit 0xc8
		_emit 0x8b
		_emit 0xc1
		_emit 0x89
		_emit 0x44
		_emit 0x24
		_emit 0x4
		_emit 0xe9
		_emit 0x44
		_emit 0xff
		_emit 0xff
		_emit 0xff
		_emit 0xb8
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc0
		_emit 0x0
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x20
		_emit 0x8b
		_emit 0x14
		_emit 0x24
		_emit 0x89
		_emit 0x14
		_emit 0x1
		_emit 0xb8
		_emit 0x4
		_emit 0x0
		_emit 0x0
		_emit 0x0
		_emit 0x48
		_emit 0x6b
		_emit 0xc0
		_emit 0x1
		_emit 0x48
		_emit 0x8b
		_emit 0x4c
		_emit 0x24
		_emit 0x20
		_emit 0x8b
		_emit 0x54
		_emit 0x24
		_emit 0x4
		_emit 0x89
		_emit 0x14
		_emit 0x1
		_emit 0x48
		_emit 0x83
		_emit 0xc4
		_emit 0x18
		_emit 0xc3
	}
}

int main() {
	// 花指令
	__asm {
		jz label3
		jnz label3
		_emit 0xE8
		label3:
	}

	printf("input your flag: ");
	unsigned char input_flag[33];
	scanf_s("%32s", input_flag, (unsigned)sizeof(input_flag));

	// 还原 key
	for (int i = 0; i < 8; i++) {
		unsigned char* k = &key[i];
		unsigned char d = xor_delta[i];

		__asm {
			_emit 0x8a		// mov     dl, [ebp+d]     ; num2
			_emit 0x55		
			_emit 0xBB
			_emit 0x8b      // mov     ecx, [ebp+k]    ; num1
			_emit 0x4d
			_emit 0xB0
		}

		__asm {
			_emit 0x68      // push 00000000    因为64的retn弹出8字节，而32位下的push只入栈4字节，需要手动多push 4字节的填充
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x68      // push 0040134F    预留好的返回地址
			_emit 0x4F
			_emit 0x13
			_emit 0x40
			_emit 0x00

			_emit 0xEA      // ljmp 0x33, 40110F (x64_opcode初地址)
			_emit 0x0F
			_emit 0x11
			_emit 0x40
			_emit 0x00
			_emit 0x33
			_emit 0x00
		}

		__asm {
			_emit 0xE8      // call $+5
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0xC7      // mov dword [rsp + 4], 0x23
			_emit 0x44
			_emit 0x24
			_emit 0x04
			_emit 0x23
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x83      // add dword [rsp], 0xD
			_emit 0x04
			_emit 0x24
			_emit 0x0D

			_emit 0xCB      // retf
		}
		// my_xor_eq(k, d);
	}
	for (int i = 0; i < 8; i++) {
		unsigned char* k = &key[i + 8];
		unsigned char d = add_delta[i];

		__asm {
			_emit 0x8a		// mov     dl, [ebp+num2]  ; num2
			_emit 0x55		// mov     ecx, [ebp+num1] ; num1
			_emit 0xba
			_emit 0x8b
			_emit 0x4d
			_emit 0xAC
		}

		__asm {
			_emit 0x68      // push 00000000    因为64的retn弹出8字节，而32位下的push只入栈4字节，需要手动多push 4字节的填充
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x68      // push 004013A9    预留好的返回地址
			_emit 0xA9
			_emit 0x13
			_emit 0x40
			_emit 0x00

			_emit 0xEA      // ljmp 0x33, 0040114F (x64_opcode初地址)
			_emit 0x4F
			_emit 0x11
			_emit 0x40
			_emit 0x00
			_emit 0x33
			_emit 0x00
		}

		__asm {
			_emit 0xE8      // call $+5
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0xC7      // mov dword [rsp + 4], 0x23
			_emit 0x44
			_emit 0x24
			_emit 0x04
			_emit 0x23
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x83      // add dword [rsp], 0xD
			_emit 0x04
			_emit 0x24
			_emit 0x0D

			_emit 0xCB      // retf
		}
		// my_sub_eq(k, d);
	}

	// TEA
	for (int i = 0; i < FlagLen / 4; i += 2) {
		uint32_t* f = (uint32_t*)input_flag + i;
		uint32_t* k = (uint32_t*)key;

		__asm {
			_emit 0x8b		// mov     edx, [ebp+var_50] ; k
			_emit 0x55		// mov     ecx, [ebp+f]    ; v
			_emit 0xa4
			_emit 0x8b
			_emit 0x4d
			_emit 0xa8
		}
		
		__asm {
			_emit 0x68      // push 00000000    因为64的retn弹出8字节，而32位下的push只入栈4字节，需要手动多push 4字节的填充
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x68      // push 004013FD    预留好的返回地址
			_emit 0xFD
			_emit 0x13
			_emit 0x40
			_emit 0x00

			_emit 0xEA      // ljmp 0x33, 0040118F (x64_opcode初地址)
			_emit 0x8F
			_emit 0x11
			_emit 0x40
			_emit 0x00
			_emit 0x33
			_emit 0x00
		}

		__asm {
			_emit 0xE8      // call $+5
			_emit 0x00
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0xC7      // mov dword [rsp + 4], 0x23
			_emit 0x44
			_emit 0x24
			_emit 0x04
			_emit 0x23
			_emit 0x00
			_emit 0x00
			_emit 0x00

			_emit 0x83      // add dword [rsp], 0xD
			_emit 0x04
			_emit 0x24
			_emit 0x0D

			_emit 0xCB      // retf
		}
		// tea(f, k);
	}

	bool res = true;
	for (int i = 0; i < FlagLen; i++) {
		res = (flag[i] == input_flag[i]);
	}
	if (res) {
		for (int i = 0; i < 14; i++) {
			success_msg[i] -= 3;
		}
		puts((char*)success_msg);
	}
	else {
		for (int i = 0; i < 6; i++) {
			failed_msg[i] += 1;
		}
		puts((char*)failed_msg);
	}

	return 0;
}